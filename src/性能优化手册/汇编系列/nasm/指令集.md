


### mov
`mov <destination> , <source>`
将目标地址的值,赋予到`<destination>`
### lea
`lea <destination> , <source>`
将目标地址的地址,赋予到`<destination>`
### cmp
比较指令
`cmp <operation_1> , <operation_2>`

### 算术指令
#### 整数
整数相加
`add <destination> , <source>
整数减法
`sub <destination> , <source>`
整数增量
`inc <operand>`
整数减量
`dec <operand>`
带进位的整数加法
`adc <dec> , <source>`
整数乘法
`mul <source>`
有符号乘法
`imul    <source>`
`imul    <destination> , <source / immediate>`
`imul    <destination> , <source> , <immediate>`
整数除法
- ）除法使用不同的指令 **无符号（ ​​div** ）除法和有符号（ **idiv** 
`div <source>`
`idiv <source>`
#### 浮点
**浮点中的数据移动**
`movss   <destination> , <source>    ; 32bit`
`movsd   <destination> , <source>    ; 64bit`
**浮点数据转换**
- 将 32 位浮点源操作数转换为 64 位浮点目标操作数。
`cvtss2sd    <RX-destination> , <source>`
- 将 64 位浮点源操作数转换为 32 位浮点目标操作数。
`cvtss2ss    <RX-destination> , <source>`
- 将 32 位浮点源操作数转换为 32 位整数目标操作数。
`cvtss2si    <register> , <source>`
- 将 64 位浮点源操作数转换为 32 位整数目标操作数。
`cvtsd2si    <register> , <source>`
- 将 32 位整数源操作数转换为 32 位浮点目标操作数。
`cvtsi2ss    <RX-destination> , <source>`
- 将 32 位整数源操作数转换为 64 位浮点目标操作数。
`cvtsi2sd    <RX-destination> , <source>`
**浮点运算指令**
```
addss  <RX_destination> , <source>
addsd  <RX_destination> , <source>
subss  <RX_destination> , <source>
subsd  <RX_destination> , <source>
mulss  <RX_destination> , <source>
mulsd  <RX_destination> , <source>
divss  <RX_destination> , <source>
divsd  <RX_destination> , <source>
sqrtss  <RX_destination> , <source>
sqrtsd  <RX_destination> , <source>
```
浮点比较指令
```
ucomiss <RX_source> , <source> ; 32bit
ucomisd <RX_source> , <source> ; 64bit
```

### 逻辑指令
AND 运算符
`and <destination> , <source>`
或运算符
`or  <destination> , <source>`
XOR 运算符
`xor <destination> , <source>`
NOT 运算符
`not <operand>`
逻辑左移
`shl <destination> , <immediate>`
`shl <destination> , cl`
逻辑右移
`shr <destination> , <immediate>`
`shr <destination> , cl`
算术左移
`ssl <destination> , <immediate>`
`ssl <destination> , cl`
算术右移
`sar <destination> , <immediate>`
`sar <destination> , cl`
左旋转操作
`rol <destination> , <immediate>`
`rol <destination> , cl`
右旋转运算
`ror <destination> , <immediate>`
`ror <destination> , cl`

### 无条件跳转指令
`jmp <label>`

### 条件跳转指令
```assembly
je  <label>         ; ==
jne <label>         ; !=

jl  <label>         ; signed <
jle <label>         ; signed <=
jg  <label>         ; signed >
jge <label>         ; signed >=

jb  <label>         ; unsigned <
jbe <label>         ; unsigned <=
ja  <label>         ; unsigned >
jae <label>         ; unsigned >=
```
### 条件设置指令
若满足条件则将 寄存器设为1,否则设为0
`<r/m8>` 表示 寄存器或内存 , 8位
```
sete  <r/m8>       ; ==
setne <r/m8>       ; !=
setq  <r/m8>       ; <
setle <r/m8>       ; >
setg  <r/m8>       ; <=
setle <r/m8>       ; >=
```

### 栈指令
`push  <operation_64>`
`pop  <operation_64>`

### 函数指令
`call <function_name>`
`ret`

### 宏指令
**单行宏**
```assembly
%define ... ...
```
**多行宏**
```assembly
%macro <name> <number_of_arguments>
    ...
%endmacro
```
